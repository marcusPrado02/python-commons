"""Alembic env boilerplate generator for projects extending mp_commons base models.

Usage
-----
From your project root::

    from mp_commons.adapters.sqlalchemy.migrations import generate_alembic_files
    generate_alembic_files(".")

This will create:
  - ``alembic.ini``  — standard Alembic configuration pointing to ``migrations/``
  - ``migrations/env.py`` — async-mode env.py pre-wired to SQLAlchemy + mp_commons
  - ``migrations/script.py.mako`` — default Alembic migration script template
  - ``migrations/versions/`` — empty directory for migration scripts
"""
from __future__ import annotations

import os
from pathlib import Path

# ---------------------------------------------------------------------------
# Template: alembic.ini
# ---------------------------------------------------------------------------

ALEMBIC_INI_TEMPLATE = """\
# Alembic configuration — generated by mp_commons
# See https://alembic.sqlalchemy.org/en/latest/tutorial.html

[alembic]
script_location = migrations
prepend_sys_path = .
version_path_separator = os

# Set DATABASE_URL env var or edit sqlalchemy.url directly.
# For async drivers use: postgresql+asyncpg://...  |  sqlite+aiosqlite://...
sqlalchemy.url = %(DATABASE_URL)s

[post_write_hooks]
# Optionally enable 'black' formatter on generated migration scripts:
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 100 REVISION_SCRIPT_FILENAME

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %%H:%%M:%%S
"""

# ---------------------------------------------------------------------------
# Template: migrations/env.py (async)
# ---------------------------------------------------------------------------

ALEMBIC_ENV_TEMPLATE = '''\
"""Alembic async env.py — generated by mp_commons."""
from __future__ import annotations

import asyncio
import os
from logging.config import fileConfig
from typing import Any

from sqlalchemy import engine_from_config, pool
from sqlalchemy.ext.asyncio import AsyncEngine, async_engine_from_config

from alembic import context

# ---------------------------------------------------------------------------
# Alembic Config object — gives access to .ini values
# ---------------------------------------------------------------------------
config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# ---------------------------------------------------------------------------
# Import your project\'s SQLAlchemy Base so Alembic can see the metadata.
# Replace the import below with your own Base if you don\'t use mp_commons:
#
#   from myapp.db import Base
#
# If you extend mp_commons models the SQLAlchemy declarative Base is available at:
#
#   from mp_commons.adapters.sqlalchemy.repository import Base
# ---------------------------------------------------------------------------
try:
    from mp_commons.adapters.sqlalchemy.repository import Base  # type: ignore[import]
    target_metadata = Base.metadata
except ImportError:
    # Fallback: set target_metadata = your_base.metadata
    target_metadata = None  # type: ignore[assignment]

# ---------------------------------------------------------------------------
# Override sqlalchemy.url from DATABASE_URL env var when present
# ---------------------------------------------------------------------------
if _db_url := os.getenv("DATABASE_URL"):
    config.set_main_option("sqlalchemy.url", _db_url)


# ---------------------------------------------------------------------------
# Offline migrations (no real connection — generates SQL)
# ---------------------------------------------------------------------------


def run_migrations_offline() -> None:
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()


# ---------------------------------------------------------------------------
# Online migrations (async engine)
# ---------------------------------------------------------------------------


def do_run_migrations(connection: Any) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)
    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """Run migrations using an async engine."""
    connectable = async_engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )
    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)
    await connectable.dispose()


def run_migrations_online() -> None:
    asyncio.run(run_async_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
'''

# ---------------------------------------------------------------------------
# Template: migrations/script.py.mako (standard Alembic template)
# ---------------------------------------------------------------------------

ALEMBIC_SCRIPT_MAKO = '''\
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from __future__ import annotations
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
'''


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------


def generate_alembic_files(
    dest_dir: str | Path = ".",
    *,
    overwrite: bool = False,
) -> list[Path]:
    """Write Alembic boilerplate files into *dest_dir*.

    Parameters
    ----------
    dest_dir:
        Root of the target project (where ``alembic.ini`` will be written).
    overwrite:
        When ``False`` (default) an existing file is **not** overwritten and
        a ``FileExistsError`` is raised instead.

    Returns
    -------
    list[Path]
        Paths of all files that were created.
    """
    root = Path(dest_dir).resolve()
    migrations = root / "migrations"
    versions = migrations / "versions"

    files: dict[Path, str] = {
        root / "alembic.ini": ALEMBIC_INI_TEMPLATE,
        migrations / "env.py": ALEMBIC_ENV_TEMPLATE,
        migrations / "script.py.mako": ALEMBIC_SCRIPT_MAKO,
    }

    created: list[Path] = []

    # Ensure directories exist
    versions.mkdir(parents=True, exist_ok=True)

    for path, content in files.items():
        path.parent.mkdir(parents=True, exist_ok=True)
        if path.exists() and not overwrite:
            raise FileExistsError(
                f"{path} already exists. Pass overwrite=True to replace it."
            )
        path.write_text(content, encoding="utf-8")
        created.append(path)

    # Create an empty .gitkeep in versions/ so git tracks the directory
    gitkeep = versions / ".gitkeep"
    if not gitkeep.exists():
        gitkeep.touch()
        created.append(gitkeep)

    return created


__all__ = [
    "ALEMBIC_ENV_TEMPLATE",
    "ALEMBIC_INI_TEMPLATE",
    "ALEMBIC_SCRIPT_MAKO",
    "generate_alembic_files",
]
